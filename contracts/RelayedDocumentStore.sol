pragma solidity 0.5.12;

import "./DocumentStore.sol";
import "@openzeppelin/contracts-ethereum-package/contracts/cryptography/ECDSA.sol";

/**
 * @dev This contract enables meta-transactions to be sent and delegated to a third party.
  *     Two roles are required: 1. relayer and 2. trustedSigner. Each being Externally Owned Accounts (EOAs).
  *     The relayer is the third party that is signing and paying for the transactions on behalf of the trustedSigner.
  *     The trusteSigner is the issuing party that is required to sign the actual messages and transaction data.
  *     This contract then relays transactions to the OpenAttestation DocumentStore on behalf of the trusedSigner.
  *     This contract is intentionally left without an owner to eliminate centralization and the potential denial of service to the
  *     trustedSigner in the case of malicious or unavailable relayers.
  *     The process for generating a valid signature is as follows:
  *       1. Generate the message to be signed. This will be either the docuementMerkleRoot or the hash of any array of docuementMerkleRoots (for batch operations).
  *         - const message = "0x3a267813bea8120f55a7b9ca814c34dd89f237502544d7c75dfd709a659f6330"; // documentMerkleRoot
  *       2. Pull the next nonce to be used from the contract.
  *       3. Generate the signature.  This signature is generated by signing the hash of: the nonce, the message, the function signature, and the relay contract address.
  *          The resulting signature should be in hex format following the Ethereum signature encoding.
  *          For example:
  *           - const message = "0x3a267813bea8120f55a7b9ca814c34dd89f237502544d7c75dfd709a659f6330";
  *             const nonce = RelayedDocumentStore.signerNonce(trustedSigner); // 1
  *             const address = RelayedDocumentStore.address; // 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0
  *             const methodSignature = signedMethodSignatures.issueRelayed; // 0x84d0f731
  *             const messageHash = web3.utils.soliditySha3(message, nonce, methodSignature, address); // 0x2bd7dce779d8d21e3266e847f21ce8160a53e6a78a65a5045f72b18081f7fc69
  *             const signature = await web3.eth.sign(messageHash, signer); // 0xf5731da089e7d9532aad446f9f92cabf3ce39c5cde8ba541cb26ed17b69ab8870a411a66ad8316d7b7478e1c1be05ca840ecfc8cc7468beb9c2832be4dc8fb1e1b
 */
contract RelayedDocumentStore {
  using ECDSA for bytes32;

  address private trustedSigner; // Account that is signing *messages*
  DocumentStore public documentStore;

  mapping(address => uint256) public signerNonce;

  event DocumentIssued(bytes32 indexed document);
  event DocumentRevoked(bytes32 indexed document);
  event RelayedMessage(address indexed relayer, address indexed trustedSigner, bytes4 functionIdentifier);

  constructor(
    string memory _name,
    address _trustedSigner
  ) public {
    require(_trustedSigner != address(0), "RelayedDocumentStore: trustedSigner is the zero address");
    trustedSigner = _trustedSigner;

    // Owner of the DocumentStore is this contract enforcing trustedSigner sign-off
    documentStore = new DocumentStore();
    documentStore.initialize(_name, address(this));
  }

  function bulkIssueRelayed(
    bytes32[] memory documents,
    bytes memory signature
  )
    public
    onlyTrustedSigner(keccak256(abi.encodePacked(documents)), signature)
  {
    documentStore.bulkIssue(documents);
  }

  function bulkRevokeRelayed(
    bytes32[] memory documents,
    bytes memory signature
  )
    public
    onlyTrustedSigner(keccak256(abi.encodePacked(documents)), signature)
  {
    documentStore.bulkRevoke(documents);
  }

  function issueRelayed(
    bytes32 document,
    bytes memory signature
  )
    public
    onlyTrustedSigner(document, signature)
  {
    documentStore.issue(document);
  }

  function revokeRelayed(
    bytes32 document,
    bytes memory signature
  )
    public
    onlyTrustedSigner(document, signature)
  {
    documentStore.revoke(document);
  }

  /**
   * @dev Throws if the message is not signed by the trusted signer or nonce incorrect.
   */
  modifier onlyTrustedSigner(bytes32 message, bytes memory signature) {
    uint256 nonce = signerNonce[trustedSigner];
    bytes memory blob = abi.encodePacked(message, nonce, msg.sig, address(this));
    address recoveredAddress = keccak256(blob).toEthSignedMessageHash().recover(signature);
    require(recoveredAddress == trustedSigner, "RelayedDocumentStore: Signature does not match the trustedSigner");

    ++signerNonce[trustedSigner];

    emit RelayedMessage(msg.sender, recoveredAddress, msg.sig);
    _;
  }
}
